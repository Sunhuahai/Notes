## 绪论
### 计算
研究在计算的过程中所蕴含的本质的内在的规律，挖掘一般性的方法和典型的技巧，实现高效的计算，同时尽量做到耗费的低廉

> computer science should becalled computing science

### 绳索计算机及其算法
如何经过一点做直线的垂线：

直线分割-勾股定理

### 尺规计算机及其算法
给定任意线段，如何将其三等分：尺规作图-平行线方法

这里的计算机是理想的直尺和圆规

算法里可能会包含另一种子算法

### 计算模型 = 计算机 = 信息处理
所谓算法，即特定计算模型下，旨在解决特定问题的指令序列

要素：
- 输入
- 输出
- 正确性
- 确定性：任一算法都可以描述为一个由基本操作组成的序列
- 可行性：每一操作都可在常数时间内完成
- 有穷性：可在有限个操作步骤内完成（*可能会难以证明*

事实：程序 ！= 算法

算法：如何设计，优化？

### 好算法
正确，健壮，可读（*结构化+准确命名+注释*）

**效率：速度尽可能快；存储空间尽可能少**

> Algorithms + Data Structures = Programs

### 性能测度
> To measure is to know.
> If you can not measure it, you can not improve it

### 算法分析
- 正确性
- 成本：运行时间 + 所需存储空间
---
如何考察？
 思路一：计算算法A求解问题实例P的计算成本

需要归纳概括 - 划分等价类

观察：问题实例的规模，但只按照规模分类也不行

例子：在平面中n个点，找到所成三角形面积最小的三个点

蛮力算法：枚举C(n, 3)种组合，计算量与运气有关。稳妥起见，可考虑**最坏情况**。

实验统计评价算法优劣：
不足够
- 适应不同规模的输入
- 适应不同类型的输入
- 不同程序员，不同语言，不同编译器
- 运行于不同的体系结构

为了给出**客观**的评价，需要抽象出一个理想的平台或模型（*图灵机模型*）

### 图灵机
- Tape 均匀的划分单元格
- Alphabet 字符的种类有限
- Head 总是对准某一单元格，并可读取和改写其中的字符
  每经过一个节拍，可转向左侧或右侧的邻格
- State TM总是处在有限状态的某一种，每经过一个节拍，可（按照规则）转向另一种状态
- Transition Function：(q, c; d, L/R, p)
  若当前状态为q且当前字符为c，则将当前字符改写为d；转向左侧/右侧的邻格；转入p状态，一旦进入特定的状态'h'，则停机

算法使用后要复位：创建规范的接口

### Random Access Machine 模型
与图灵机的相同点：

- 寄存器顺序编号，总数没有限制
- 每一基本操作仅需常数时间
- 与图灵模型都是一般计算工具的抽象，可以对算法的效率做出可信的比较与评判

在这些模型中：
算法的运行时间 正比于 算法需要执行的基本操作次数

### 大O记号
T(n)  = O(f(n)) iff 存在c > 0, 当 n >> 2后，有T(n) < cf(n)

- O(1) 不含转向（循环，判断，递归）
- O(logn) 非常有效，复杂度无限接近O(1)
- O(n^c) 也已经令人满意，凡是多项式复杂度，均可认为不可解
- O(2^n) 